# Тестовое задание для Философия.ИТ

## Задание
Реализация интеграции с АСФС. Работа с кассовыми ордерами.

## Описание
Протокол взаимодействия описан в as_fs.xsd.
В данной задаче нужно обработать следующие функции интеграции: SrvCheckOverLimitRq, SrvCreateCashOrderRq, SrvGetWorkPlaceInfoRq, SrvUpdStCashOrderRq.

## Шаги
- Добавить maven плагин для генерации транспортных сущностей по указанному xsd-файлу.
- Обновить сущности приложения, расположенные в ufs-model, чтобы они могли участвовать в интеграции.
Требуется создать новую сущность в ufs-model, назвать, например, CashOrder. заполнить её полями на основе транспортных сущностей, что указаны в задаче.
В своей модели добавляем мы сущность CashOrder, из неё мы можем создавать Rq объекты на добавление ордера, обновление статуса и тому подобное. Также еще в DTO есть подсущность AddititionalInfo. В своей модели нам не обязательно создавать себе такую же. Её атрибуты можно размещать в самом CashOrder. Также, видя, что есть атрибуты, относящиеся к подразделению, то в CashOrder можно добавить поля типа Subbranch (эта сущность уже есть у нас) и в него вносить значения этих атрибутов.
Вас может смутить наличие в Кассовом ордере двух типов KO1 и KO2. В рамках нашей задачи будем считать, что используются только KO1, структуру KO2 в DTO обрабатывать не будем. Структуру данных xsd нам предоставляет мастер-система (в данном случае какой-то аналитик, который нарисовал эти xsd файлы на основе анализа бизнес-процессов банка). Влиять на состав атрибутов мы не можем, но можем использовать или не использовать эти атрибуты.
Не создавайте пожалуйста сущностей: CreateCashOrderRequest, UpdateStatusCashOrderRequest, WorkPlaceInfoRequest. Это не наш путь.
- Создать адаптеры между сущностями приложения и транспортными сущностями в ufs-is-esb. 
Примеры создания адаптеров можно посмотреть в реализации адаптеров для ЕКС и ППРБ. (маппинг осуществить двумя способами – классическим и при помощи библиотеки MapStruct, стиль написания классического адаптера должен соответствовать другим адаптерам, с кучей статических map() методов)
- Создать коллекции в hazelcast для хранения результатов запрошенных функций.
- Добавить обработку запросов из hazelcast на вызов новых интеграционных функций.
- Добавить обработку ответов от АС ФС и размещения результата в коллекциях hazelcast.
- В приложении mock-bs добавить формирование ответов на запросы в АСФС, обрабатываемые в данном задании.
Требуется сохранять все созданные КО в кэш приложения mock-bs, там их обновлять. Проверку Лимита следует выполнять на основе суммы КО за день по пользователю.
В приложении ufs-be методы класса MockCacheImpl: getWorkplace, checkOverLimit следует перенести в HazelcastCacheImpl, с соответствующим преобразованием логики работы методов.
В класс HazelcastCacheImpl также надо добавить методы работы с Кассовыми ордерами, и вызывать их в методах добавления и подтверждения операций класса OperationProvider.
Нужно внести в сущность Operation поле cashOrderId и заполнять его созданным предварительно Кассовым ордером.
- В довершении предлагаем добавить в REST API приложения ufs-be новый отчет – Кассовая книга.
Имеется в ufs-be контроллер ReportController, где описано формирование Журнала операций. В этот контроллер внести новый метод, возвращающей данные для кассовой книги. Состав атрибутов этого отчёта произвольный. Для упрощения реализации источником данных отчёта может стать особая коллекция в hazelcast, где будут накапливаться все подтверждённые КО. (т.к. нет у нас специального метода запроса списка КО из АСФС).
Все созданные классы должны быть покрыты тестами.
